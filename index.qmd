---
title: "Patrick’s Auto Shop Productivity Report"
subtitle: "Where Should You Spend Your Time?"
format:
  html:

  theme:
    light: [cosmo]
    dark: [slate]
  toc: true
  toc-location: left
  toc-depth: 2
  code-copy: true
  code-tools: true
  df-print: paged
  anchor-sections: true
  page-layout: article
  css: custom_theme.css
    toc: true
    code-fold: true
    smooth-scroll: true
execute:
  echo: false
  warning: false
  message: false
---

## The Bottom Line

Patrick, here’s what your data tells us in plain language:

- Your presence **does not help every shop equally**.
- Some shops show a **big, reliable jump** in cars fixed when you’re there.
- Others run **nearly as well without you**.

**Recommendation:** Focus your week on the **top two shops** by _Boss Boost_ (Present − Away). Your brother’s shop typically benefits **least** from your presence — visit occasionally, not routinely.

***

```{python}
#| label: setup
#| include: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from matplotlib.ticker import MaxNLocator
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (imported for 3D)

plt.style.use("default")

# ---- Load & basic checks ----
df = pd.read_csv("carsFixed.csv").copy()
df["shopID"] = df["shopID"].astype(str)

exp_cols = {"shopID", "boss", "carsFixed"}
miss = exp_cols.difference(df.columns)
if miss:
    raise ValueError(f"Missing expected columns: {miss}")

# Map boss indicator to readable labels
uniq = sorted(df["boss"].unique())
if set(uniq) == {0,1}:
    boss_map = {0:"Away", 1:"Present"}
else:
    boss_map = {v:str(v) for v in uniq}
df["bossLabel"] = df["boss"].map(boss_map)

# Summary table and means
summary = (df.groupby(["shopID","bossLabel"])["carsFixed"]
             .agg(count="count", mean="mean", std="std", min="min", max="max")
             .reset_index())

means = df.groupby(["shopID","bossLabel"])["carsFixed"].mean().unstack()
if "Present" in means.columns and "Away" in means.columns:
    means["boss_boost"] = means["Present"] - means["Away"]
else:
    means["boss_boost"] = np.nan

boost_tbl = means.reset_index().sort_values("boss_boost", ascending=False)

# Bootstrap CIs per shop
def _boot_shop(sub, n=2000):
    if not (("Present" in sub["bossLabel"].values) and ("Away" in sub["bossLabel"].values)):
        return None
    a = sub.loc[sub["bossLabel"]=="Away","carsFixed"].to_numpy()
    p = sub.loc[sub["bossLabel"]=="Present","carsFixed"].to_numpy()
    if len(a)==0 or len(p)==0: 
        return None
    outs = []
    for _ in range(n):
        outs.append(np.random.choice(p, size=p.size, replace=True).mean()
                    - np.random.choice(a, size=a.size, replace=True).mean())
    outs = np.array(outs)
    return outs.mean(), np.quantile(outs,0.025), np.quantile(outs,0.975)

rows = []
for shop, sub in df.groupby("shopID"):
    z = _boot_shop(sub)
    if z is not None:
        rows.append({"shopID": str(shop), "effect_mean": z[0], "ci_lower": z[1], "ci_upper": z[2]})
ci = pd.DataFrame(rows) if rows else None
```

## What the Data Shows

We analyzed **250 shop-days** across 5 shops. Each point below is one day; horizontal tick marks show the mean for _Away_ vs _Present_.

```{python}
#| label: fig-allpoints
#| fig-cap: "All 250 days — one dot per day, by shop and boss presence"
fig, ax = plt.subplots(figsize=(9,4.6))

shops = sorted(df["shopID"].unique())
xpos = {(shop,"Away"): i-0.13 for i,shop in enumerate(shops)}
xpos.update({(shop,"Present"): i+0.13 for i,shop in enumerate(shops)})

for (shop, status), sub in df.groupby(["shopID","bossLabel"]):
    x = xpos[(shop,status)] + 0.045*(np.random.rand(len(sub)) - 0.5)
    ax.scatter(x, sub["carsFixed"], s=22, alpha=0.55)

# Mean ticks
if "Present" in means.columns and "Away" in means.columns:
    for i, shop in enumerate(shops):
        row = means.loc[shop]
        if not np.isnan(row.get("Away", np.nan)):
            ax.hlines(row["Away"], i-0.33, i-0.05, linewidth=2)
        if not np.isnan(row.get("Present", np.nan)):
            ax.hlines(row["Present"], i+0.05, i+0.33, linewidth=2)

ax.set_xticks(range(len(shops)))
ax.set_xticklabels([f"Shop {s}" for s in shops])
ax.set_ylabel("Cars fixed per day")
ax.grid(axis="y", alpha=0.3)
plt.tight_layout(); plt.show()
```

***

## Distribution Comparison: Violin Plot

Violin plots show the **full distribution** of productivity (not just the average).

```{python}
#| label: fig-violin
#| fig-cap: "Productivity distributions by shop & presence"
fig, axes = plt.subplots(1, len(shops), figsize=(11,4), sharey=True)
for i, shop in enumerate(shops):
    sub = df[df["shopID"]==shop]
    data_away = sub.loc[sub["bossLabel"]=="Away","carsFixed"].to_numpy()
    data_pres = sub.loc[sub["bossLabel"]=="Present","carsFixed"].to_numpy()
    parts = axes[i].violinplot([data_away, data_pres], showmeans=True, showmedians=False, showextrema=False)
    axes[i].set_title(f"Shop {shop}")
    axes[i].set_xticks([1,2]); axes[i].set_xticklabels(["Away","Present"])
    axes[i].yaxis.set_major_locator(MaxNLocator(integer=True))
    axes[i].grid(axis="y", alpha=0.3)
axes[0].set_ylabel("Cars fixed per day")
plt.tight_layout(); plt.show()
```

***

## Split Violin Plot: Direct Comparison by Shop

Each shop’s two distributions plotted back-to-back for a **direct** comparison.

```{python}
#| label: fig-split-violin
#| fig-cap: "Split-violin per shop (Away vs Present)"
def half_violin(ax, data, pos, side="left", width=0.8):
    vp = ax.violinplot([data], positions=[pos], widths=width, showmeans=False, showmedians=False, showextrema=False)
    for b in vp['bodies']:
        m = np.mean(b.get_paths()[0].vertices[:,0])
        verts = b.get_paths()[0].vertices
        if side=="left":
            verts[:,0] = np.minimum(verts[:,0], m)
        else:
            verts[:,0] = np.maximum(verts[:,0], m)
        b.set_alpha(0.6)

fig, ax = plt.subplots(figsize=(9,4.2))
positions = np.arange(1, len(shops)+1)
for i, shop in enumerate(shops, start=1):
    sub = df[df["shopID"]==shop]
    a = sub.loc[sub["bossLabel"]=="Away","carsFixed"].to_numpy()
    p = sub.loc[sub["bossLabel"]=="Present","carsFixed"].to_numpy()
    if len(a)>0:
        half_violin(ax, a, i, side="left", width=0.8)
    if len(p)>0:
        half_violin(ax, p, i, side="right", width=0.8)
    # Means (diamonds)
    if "Away" in means.columns:
        ma = means.loc[shop].get("Away", np.nan)
        if not np.isnan(ma):
            ax.scatter(i-0.05, ma, marker="D")
    if "Present" in means.columns:
        mp = means.loc[shop].get("Present", np.nan)
        if not np.isnan(mp):
            ax.scatter(i+0.05, mp, marker="D")
ax.set_xticks(positions); ax.set_xticklabels([f"Shop {s}" for s in shops])
ax.set_ylabel("Cars fixed per day")
ax.grid(axis="y", alpha=0.3)
plt.tight_layout(); plt.show()
```

***

## 3D View: Shop Performance Landscape

A 3D perspective combining shop, presence, and cars fixed.

```{python}
#| label: fig-3d
#| fig-cap: "3D: Shop × Presence × Cars"
from mpl_toolkits.mplot3d import Axes3D  # noqa
fig = plt.figure(figsize=(8.5,5.5))
ax = fig.add_subplot(111, projection='3d')

status_to_x = {"Away":0, "Present":1}
xs, ys, zs = [], [], []
for _, r in df.iterrows():
    xs.append(status_to_x.get(r["bossLabel"], 0))
    ys.append(int(r["shopID"]))
    zs.append(r["carsFixed"])
ax.scatter(xs, ys, zs, s=10, alpha=0.6)

# Bars at means
for shop in shops:
    y = int(shop)
    if "Away" in means.columns and not np.isnan(means.loc[shop].get("Away", np.nan)):
        ax.bar3d(0, y-0.2, 0, 0.3, 0.4, means.loc[shop]["Away"], alpha=0.4)
    if "Present" in means.columns and not np.isnan(means.loc[shop].get("Present", np.nan)):
        ax.bar3d(1, y-0.2, 0, 0.3, 0.4, means.loc[shop]["Present"], alpha=0.4)

ax.set_xlabel("Presence (0=Away, 1=Present)")
ax.set_ylabel("Shop")
ax.set_zlabel("Cars fixed")
plt.tight_layout(); plt.show()
```

***

## The “Boss Boost” Effect

How many **extra cars** are fixed when you’re present?

```{python}
#| label: tbl-boost
#| tbl-cap: "Boss Boost = mean(present) − mean(away)"
view = boost_tbl[["shopID"]].copy()
view["Mean (Away)"] = means.get("Away", np.nan).reindex(boost_tbl["shopID"]).values
view["Mean (Present)"] = means.get("Present", np.nan).reindex(boost_tbl["shopID"]).values
view["Boss Boost (Δ cars/day)"] = boost_tbl["boss_boost"].values
view.round(2)
```

```{python}
#| label: fig-boost
#| fig-cap: "Extra cars per day when you’re present (by shop)"
fig, ax = plt.subplots(figsize=(7.2,3.9))
bb = boost_tbl.fillna(0)
ax.bar([f"Shop {s}" for s in bb["shopID"]], bb["boss_boost"], alpha=0.9)
ax.axhline(0, linewidth=1)
ax.set_ylabel("Δ cars/day")
ax.grid(axis="y", alpha=0.3)
for i, v in enumerate(bb["boss_boost"]):
    ax.text(i, v, f"{v:.1f}", ha="center", va="bottom" if v>=0 else "top", fontsize=9)
plt.tight_layout(); plt.show()
```

***

## How Confident Can You Be?

```{python}
#| label: tbl-ci
#| tbl-cap: "Bootstrap CIs for shop-level Boss Boost"
ci.round(2) if ci is not None else pd.DataFrame({"Note": ["Insufficient variation to estimate CIs."]})
```

```{python}
#| label: fig-ci
#| fig-cap: "Effect ± confidence interval by shop"
if ci is not None:
    order = [s for s in boost_tbl["shopID"] if s in set(ci["shopID"])]
    dat = ci.set_index("shopID").loc[order].reset_index()
    fig, ax = plt.subplots(figsize=(7.2,3.9))
    x = np.arange(len(dat))
    y = dat["effect_mean"].to_numpy()
    lo = dat["ci_lower"].to_numpy()
    hi = dat["ci_upper"].to_numpy()
    ax.errorbar(x, y, yerr=[y-lo, hi-y], fmt="o", capsize=4)
    ax.axhline(0, linestyle="--", linewidth=1)
    ax.set_xticks(x); ax.set_xticklabels([f"Shop {s}" for s in dat["shopID"]])
    ax.set_ylabel("Boss Boost (cars/day)")
    ax.grid(axis="y", alpha=0.3)
    plt.tight_layout(); plt.show()
else:
    import matplotlib.pyplot as plt
    fig, ax = plt.subplots()
    ax.text(0.5, 0.5, "Not enough Present/Away variation for CIs.", ha="center", va="center")
    ax.axis("off"); plt.tight_layout(); plt.show()
```

***

## The Money Question

Assume **$200 profit per car**. Compare monthly strategies (22 working days):

```{python}
#| label: fig-money-month
#| fig-cap: "Extra profit per month by strategy (illustrative)"
profit_per_car = 200.0
workdays = 22
shops = list(means.index)

def expected_cars(plan):
    tot = 0.0
    for shop in shops:
        days_present = plan.get(shop, 0.0)
        days_away = workdays - days_present
        row = means.loc[shop]
        mA = row.get("Away", row.mean())
        mP = row.get("Present", mA)
        tot += days_present*mP + days_away*mA
    return tot

# Strategies: Even, Optimal (top 2), Brother-only, Never
even = {s: workdays/len(shops) for s in shops}
sorted_boost = boost_tbl.sort_values("boss_boost", ascending=False)
top2 = list(sorted_boost["shopID"][:2]) if len(sorted_boost)>=2 else list(sorted_boost["shopID"])
optimal = {s: 0.0 for s in shops}
if len(top2)>0:
    each = workdays/len(top2)
    for s in top2: optimal[s] = each
fav = "3" if "3" in shops else shops[0]
brother = {s:0.0 for s in shops}; brother[fav] = workdays
never = {s:0.0 for s in shops}

base = expected_cars(never)
extra = {
    "Optimal (Top 2)": expected_cars(optimal)-base,
    "Even Split": expected_cars(even)-base,
    "Brother Only": expected_cars(brother)-base,
}
money = {k: v*profit_per_car for k,v in extra.items()}

fig, ax = plt.subplots(figsize=(7.2,3.9))
labels = list(money.keys()); vals = [money[k] for k in labels]
bars = ax.bar(labels, vals, alpha=0.9)
ax.set_ylabel("Extra profit per month (USD)")
ax.grid(axis="y", alpha=0.3)
for b in bars:
    h=b.get_height()
    ax.text(b.get_x()+b.get_width()/2, h, f"${h:,.0f}", ha="center", va="bottom", fontsize=9)
plt.tight_layout(); plt.show()
```

### Long-Term Profit Projection (12 months)

```{python}
#| label: fig-money-year
#| fig-cap: "Cumulative extra profit over 12 months"
months = np.arange(1,13)
vals = [money[k] for k in labels]

fig, ax = plt.subplots(figsize=(7.2,3.9))
for lab, val in zip(labels, vals):
    ax.plot(months, months*val, marker="o", label=lab)
ax.set_xlabel("Month"); ax.set_ylabel("Cumulative extra profit (USD)")
ax.grid(alpha=0.3); ax.legend(frameon=False)
plt.tight_layout(); plt.show()
```

***

## Your Action Plan

**Priority schedule (start next week):**

- **2–3 days** in the **highest-boost** shop  
- **2–3 days** in the **second-highest-boost** shop  
- **Occasional** check-ins elsewhere (including your brother’s shop)

**What could go wrong & mitigations:**

1. **Small samples** in some shops → keep logging data; re-check quarterly.  
2. **Seasonality** → include month/day-of-week in future models if patterns shift.  
3. **Staff changes** → if a lower-boost shop hires new techs, reassess.

***

## Summary

- Your presence matters — but **not equally everywhere**.  
- Focusing on the **top two shops** adds the most cars (and dollars).  
- The **money charts** show large gains from a smarter weekly schedule.  
- **Re-run quarterly** and adjust as the data evolve.
