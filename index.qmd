---
title: "Patrick’s Auto Shops – Decision Brief"
subtitle: "Using your daily shop data to design your weekly schedule"
format:
  html:
    toc: true
    toc-title: "Report outline"
    toc-location: left
    toc-depth: 2
    number-sections: true
    code-fold: true
    smooth-scroll: true
    anchor-sections: true
execute:
  echo: false
  warning: false
  message: false
---

# Snapshot: What you should do

Patrick, here is the short version your data supports:

- Your presence **helps some shops a lot more than others**.
- A small set of shops get a **big, repeatable jump** when you show up.
- Other shops tick along **almost the same** whether you are there or not.

A simple, data-backed plan is:

- Spend **most of your week** in the **two shops where your presence adds the most cars per day**.
- Visit the other shops (including your brother’s) **only for specific reasons**: training, big repairs, morale.

The rest of this brief explains:

1. What your daily data actually look like across shops.
2. How much you help each shop and how certain we are.
3. What different schedules mean in **dollars per month**.
4. A concrete weekly schedule you can follow.

---

```{python}
#| echo: false
#| label: setup
#| include: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

plt.style.use("default")

# Load data
df = pd.read_csv("carsFixed.csv").copy()
df["shopID"] = df["shopID"].astype(str)

required = {"shopID", "boss", "carsFixed"}
missing = required.difference(df.columns)
if missing:
    raise ValueError(f"Missing required columns: {missing}")

# Map boss indicator to labels
uniq = sorted(df["boss"].unique())
if set(uniq) == {0, 1}:
    boss_map = {0: "Away", 1: "Present"}
else:
    boss_map = {v: str(v) for v in uniq}
df["bossLabel"] = df["boss"].map(boss_map)

# Summary by shop and presence
summary = (
    df.groupby(["shopID", "bossLabel"])["carsFixed"]
      .agg(count="count", mean="mean", std="std", q25=lambda x: np.quantile(x, 0.25), q75=lambda x: np.quantile(x, 0.75))
      .reset_index()
)

# Means table
means = df.groupby(["shopID", "bossLabel"])["carsFixed"].mean().unstack()

if "Present" in means.columns and "Away" in means.columns:
    means["boss_boost"] = means["Present"] - means["Away"]
else:
    means["boss_boost"] = np.nan

boost_tbl = means.sort_values("boss_boost", ascending=False).reset_index()

# Bootstrap CIs for boss boost
def bootstrap_boost(sub, n_boot=2000):
    labels = sub["bossLabel"].unique()
    if not (("Present" in labels) and ("Away" in labels)):
        return None
    present = sub.loc[sub["bossLabel"] == "Present", "carsFixed"].to_numpy()
    away    = sub.loc[sub["bossLabel"] == "Away", "carsFixed"].to_numpy()
    if len(present) == 0 or len(away) == 0:
        return None
    diffs = []
    for _ in range(n_boot):
        diffs.append(
            np.random.choice(present, size=len(present), replace=True).mean()
            - np.random.choice(away,    size=len(away),    replace=True).mean()
        )
    diffs = np.array(diffs)
    return diffs.mean(), np.quantile(diffs, 0.025), np.quantile(diffs, 0.975)

rows = []
for shop, sub in df.groupby("shopID"):
    out = bootstrap_boost(sub)
    if out is not None:
        rows.append({"shopID": str(shop), "effect_mean": out[0], "ci_lower": out[1], "ci_upper": out[2]})
ci_df = pd.DataFrame(rows) if rows else None
```

# What the data show

Each row in `carsFixed.csv` is one **shop-day**:

- which shop it was,
- whether you were **away** or **present**, and
- how many cars were fixed.

```{python}
#| echo: false
#| label: tbl-head
#| tbl-cap: "First 10 days in the dataset"
df.head(10)
```

```{python}
#| echo: false
#| label: tbl-summary
#| tbl-cap: "Summary statistics by shop and boss presence"
summary.round(2)
```

## All shop-days in one view

This figure shows **every recorded day** in the data, colored by your presence and arranged by shop.

```{python}
#| echo: false
#| label: fig-all-points
#| fig-cap: "All days in the dataset: one dot per day, colored by your presence"
shops = sorted(df["shopID"].unique())
boss_levels = ["Away", "Present"]

fig, axes = plt.subplots(1, len(shops), figsize=(11, 4), sharey=True)

if len(shops) == 1:
    axes = [axes]

for ax, shop in zip(axes, shops):
    sub = df[df["shopID"] == shop]
    for j, bl in enumerate(boss_levels):
        vals = sub.loc[sub["bossLabel"] == bl, "carsFixed"].to_numpy()
        if len(vals) == 0:
            continue
        x_j = j + 1 + 0.12 * (np.random.rand(len(vals)) - 0.5)
        ax.scatter(x_j, vals, alpha=0.6, s=20)
    ax.set_xticks([1, 2])
    ax.set_xticklabels(boss_levels)
    ax.set_title(f"Shop {shop}")
    ax.grid(axis="y", alpha=0.3)

axes[0].set_ylabel("Cars fixed per day")
plt.tight_layout()
plt.show()
```

## Distribution comparison by shop (box + jitter, not violins)

Here we show the **spread** of productivity at each shop with and without you, using boxplots plus jittered points (no violin shapes).

```{python}
#| echo: false
#| label: fig-box-strip
#| fig-cap: "Daily productivity by shop and presence: boxplots with individual days"
shops = sorted(df["shopID"].unique())
n_shops = len(shops)

fig, axes = plt.subplots(1, n_shops, figsize=(11, 4), sharey=True)
if n_shops == 1:
    axes = [axes]

for ax, shop in zip(axes, shops):
    sub = df[df["shopID"] == shop]
    away_vals = sub.loc[sub["bossLabel"] == "Away", "carsFixed"].to_numpy()
    pres_vals = sub.loc[sub["bossLabel"] == "Present", "carsFixed"].to_numpy()
    data = [away_vals, pres_vals]

    # Boxplot
    ax.boxplot(data, showmeans=True)

    # Jittered points
    for j, vals in enumerate(data, start=1):
        if len(vals) == 0:
            continue
        x_j = j + 0.10 * (np.random.rand(len(vals)) - 0.5)
        ax.scatter(x_j, vals, s=18, alpha=0.5)

    ax.set_title(f"Shop {shop}")
    ax.set_xticks([1, 2])
    ax.set_xticklabels(["Away", "Present"])
    ax.grid(axis="y", alpha=0.3)

axes[0].set_ylabel("Cars fixed per day")
plt.tight_layout()
plt.show()
```

## 3D view: shop × presence × cars

To give you a different angle on the same data, this 3D plot summarizes the **average cars per day** for each shop and presence combination.

```{python}
#| echo: false
#| label: fig-3d
#| fig-cap: "3D view: average cars/day by shop and boss presence"
shops = list(means.index)
boss_cols = [c for c in means.columns if c in ["Away", "Present"]]

fig = plt.figure(figsize=(7.5, 5))
ax = fig.add_subplot(111, projection="3d")

xs = []
ys = []
zs = []
labels = []

for i, shop in enumerate(shops):
    for j, bl in enumerate(boss_cols):
        xs.append(i)
        ys.append(j)
        zs.append(means.loc[shop, bl])
        labels.append((shop, bl))

ax.bar3d(xs, ys, [0]*len(zs), 0.4, 0.4, zs, shade=True)
ax.set_xticks(range(len(shops)))
ax.set_xticklabels([f"Shop {s}" for s in shops])
ax.set_yticks(range(len(boss_cols)))
ax.set_yticklabels(boss_cols)
ax.set_zlabel("Mean cars/day")
ax.set_title("Average productivity in 3D (shop × presence)")
plt.tight_layout()
plt.show()
```

# How much do you help each shop?

## “Boss boost” table

We define:

> **Boss boost = mean cars/day when you are Present − mean cars/day when you are Away.**

```{python}
#| echo: false
#| label: tbl-boost
#| tbl-cap: "Shops ranked by extra cars/day when you are present"
boost_view = boost_tbl[["shopID"]].copy()
boost_view["Mean (Away)"] = means.get("Away", np.nan).reindex(boost_tbl["shopID"]).values
boost_view["Mean (Present)"] = means.get("Present", np.nan).reindex(boost_tbl["shopID"]).values
boost_view["Boss boost (Δ cars/day)"] = boost_tbl["boss_boost"].values
boost_view.round(2)
```

## Boss boost as a horizontal bar chart (with CIs)

This figure shows where your time **creates the most extra cars per day**, with uncertainty bars when we can estimate them.

```{python}
#| echo: false
#| label: fig-boost-bars
#| fig-cap: "Extra cars/day when you are present, with uncertainty bars"
fig, ax = plt.subplots(figsize=(7.2, 4.2))

order = list(boost_tbl["shopID"])
y_pos = np.arange(len(order))

boost_vals = boost_tbl.set_index("shopID").loc[order, "boss_boost"].to_numpy()

if ci_df is not None and not ci_df.empty:
    aligned = ci_df.set_index("shopID").loc[order]
    effects = aligned["effect_mean"].to_numpy()
    lower = aligned["ci_lower"].to_numpy()
    upper = aligned["ci_upper"].to_numpy()
    ax.barh(y_pos, effects, xerr=[effects - lower, upper - effects],
            alpha=0.85, capsize=4)
else:
    ax.barh(y_pos, boost_vals, alpha=0.85)

ax.axvline(0, linestyle="--", linewidth=1, color="black")
ax.set_yticks(y_pos)
ax.set_yticklabels([f"Shop {s}" for s in order])
ax.set_xlabel("Extra cars/day when present (Boss boost)")
ax.set_title("Where your presence moves the needle most")
ax.grid(axis="x", alpha=0.3)

plt.tight_layout()
plt.show()
```

# How confident can you be?

```{python}
#| echo: false
#| label: tbl-ci
#| tbl-cap: "Bootstrap confidence intervals for boss boost by shop"
ci_df.round(2) if ci_df is not None and not ci_df.empty else pd.DataFrame(
    {"Note": ["Not enough Present/Away variation in every shop to estimate intervals."]}
)
```

In plain language:

- If a shop’s entire interval is **above 0**, you almost certainly help there.
- If an interval overlaps 0, the signal is weaker; that shop is lower priority until more data accumulate.

# What different schedules mean in money

Assume:

- **$200 profit per car**, and
- **22 working days per month**.

We compare three simple schedules:

1. **Even split** – equal time at all shops.  
2. **Focus top-2** – all your time at the two highest-boost shops.  
3. **Brother-only** – all your time at your brother’s shop (shop 3 if it exists; otherwise the first shop).  

```{python}
#| echo: false
#| label: fig-money
#| fig-cap: "Extra profit per month vs a 'never visit' baseline"
profit_per_car = 200.0
workdays = 22
shops = list(means.index)

def expected_cars(plan_days_present):
    total = 0.0
    for s in shops:
        days_present = plan_days_present.get(s, 0.0)
        days_away = workdays - days_present
        row = means.loc[s]
        mA = row.get("Away", row.mean())
        mP = row.get("Present", mA)
        total += days_present * mP + days_away * mA
    return total

# Baseline: never visit
never = {s: 0.0 for s in shops}
base_cars = expected_cars(never)

# 1) Even split
even = {s: workdays / len(shops) for s in shops}

# 2) Focus top-2
sorted_boost = boost_tbl.sort_values("boss_boost", ascending=False)
top2 = list(sorted_boost["shopID"][:2]) if len(sorted_boost) >= 2 else list(sorted_boost["shopID"])
focus = {s: 0.0 for s in shops}
if len(top2) > 0:
    days_each = workdays / len(top2)
    for s in top2:
        focus[s] = days_each

# 3) Brother-only
fav = "3" if "3" in shops else shops[0]
brother = {s: 0.0 for s in shops}
brother[fav] = workdays

scenarios = {"Even split": even, "Focus top-2": focus, "Brother-only": brother}

extra_profit = {}
for name, plan in scenarios.items():
    cars = expected_cars(plan)
    extra_cars = cars - base_cars
    extra_profit[name] = extra_cars * profit_per_car

labels = list(extra_profit.keys())
vals = [extra_profit[k] for k in labels]

fig, ax = plt.subplots(figsize=(7, 4))
bars = ax.bar(labels, vals, alpha=0.9)
ax.set_ylabel("Extra profit per month (USD)")
ax.set_title("What different schedules mean in money")
ax.grid(axis="y", alpha=0.3)

for b in bars:
    h = b.get_height()
    ax.text(b.get_x() + b.get_width()/2, h, f"${h:,.0f}", ha="center", va="bottom", fontsize=9)

plt.tight_layout()
plt.show()
```

## 12‑month projection

Here we project the same three strategies over 12 months, assuming the pattern continues.

```{python}
#| echo: false
#| label: fig-projection
#| fig-cap: "Cumulative extra profit over 12 months for each strategy"
months = np.arange(1, 13)
fig, ax = plt.subplots(figsize=(7, 4))

for name in labels:
    monthly = extra_profit[name]
    cum_vals = months * monthly
    ax.plot(months, cum_vals, marker="o", label=name)

ax.set_xlabel("Months")
ax.set_ylabel("Cumulative extra profit (USD)")
ax.set_title("Long-term impact of different schedules")
ax.grid(alpha=0.3)
ax.legend(frameon=False)

plt.tight_layout()
plt.show()
```

# Recommended weekly plan (pulling it together)

Based on the boss-boost rankings and CIs:

- Spend **roughly half of your days** at the **highest‑boost shop**.
- Spend the **other half** at the **second‑highest‑boost shop**. One simple pattern is **Mon–Wed** at the top shop and **Thu–Fri** at the second.
- Visit other shops, including your brother’s, **only when there is a clear reason** (new staff, big jobs, problems).

Re-run this brief every few months:

- If the ranking of shops changes, rotate your schedule.
- Keep logging data so the recommendations stay current.

# Appendix — full summary table

```{python}
#| echo: false
#| label: tbl-summary-full
#| tbl-cap: "Summary statistics used across the report"
summary.round(2)
```